# .github/workflows/cd-deploy.yaml
# CD Pipeline: ëª¨ë¸ ë¹Œë“œ ë° KServe ë°°í¬
#
# íŠ¸ë¦¬ê±°: CI ì„±ê³µ í›„, main ë¸Œëœì¹˜ push, ë˜ëŠ” ìˆ˜ë™ ì‹¤í–‰

name: CD - Deploy to KServe

on:
  # CI ì™„ë£Œ í›„ ìë™ ì‹¤í–‰
  workflow_run:
    workflows: ["CI - Test & Build"]
    types: [completed]
    branches: [main]
  
  # main ë¸Œëœì¹˜ì— push ì‹œ ìë™ ì‹¤í–‰
  push:
    branches: [main]
    paths:
      - 'day3/lab3-2_monitoring-cicd/**'
      - '.github/workflows/cd-deploy.yaml'
  
  # ìˆ˜ë™ ì‹¤í–‰ (workflow_dispatch)
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - staging
          - production
      user_namespace:
        description: 'Target user namespace (e.g., kubeflow-user01)'
        required: true
        default: 'YOUR_NAMESPACE'

env:
  AWS_REGION: ap-northeast-2
  MODEL_NAME: california-housing
  SOURCE_PATH: day3/lab3-2_monitoring-cicd
  ECR_REGISTRY: 'YOUR_ECR_REGISTRY'
  ECR_REPOSITORY: 'YOUR_ECR_REPOSITORY'
  EKS_CLUSTER_NAME: 'YOUR_EKS_CLUSTER_NAME'
  NAMESPACE: YOUR_NAMESPACE

jobs:
  # ============================================================
  # Job 1: Docker ë¹Œë“œ & ECR í‘¸ì‹œ
  # ============================================================
  build-and-push:
    name: Build & Push to ECR
    runs-on: ubuntu-latest
    # âœ… ìˆ˜ì •: push ì´ë²¤íŠ¸ë„ ì§€ì›í•˜ë„ë¡ ì¡°ê±´ ë³€ê²½
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      github.event_name == 'workflow_dispatch' ||
      github.event_name == 'push'
    
    outputs:
      image_digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Create ECR repository if not exists
        run: |
          aws ecr describe-repositories --repository-names ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }} 2>/dev/null || \
          aws ecr create-repository --repository-name ${{ env.ECR_REPOSITORY }} --region ${{ env.AWS_REGION }}
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ${{ env.SOURCE_PATH }}
          push: true
          tags: |
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}
            ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64
      
      - name: Output image info
        run: |
          echo "ğŸ“¦ Image pushed successfully!"
          echo "   Image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${{ github.sha }}"
          echo "   Digest: ${{ steps.build.outputs.digest }}"

  # ============================================================
  # Job 2: KServe ë°°í¬
  # ============================================================
  deploy-kserve:
    name: Deploy to KServe
    runs-on: ubuntu-latest
    needs: build-and-push
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
      
      - name: Configure kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
      
      - name: Set deployment namespace
        id: namespace
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "namespace=${{ github.event.inputs.user_namespace }}" >> $GITHUB_OUTPUT
          else
            echo "namespace=${{ env.NAMESPACE }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Deploy InferenceService
        env:
          IMAGE_TAG: ${{ github.sha }}
          DEPLOY_NAMESPACE: ${{ steps.namespace.outputs.namespace }}
        run: |
          cat <<EOF | kubectl apply -f -
          apiVersion: serving.kserve.io/v1beta1
          kind: InferenceService
          metadata:
            name: ${{ env.MODEL_NAME }}
            namespace: ${DEPLOY_NAMESPACE}
            annotations:
              sidecar.istio.io/inject: "false"
          spec:
            predictor:
              minReplicas: 1
              maxReplicas: 3
              containers:
                - name: kserve-container
                  image: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY }}:${IMAGE_TAG}
                  ports:
                    - containerPort: 8080
                      protocol: TCP
                  env:
                    - name: MODEL_NAME
                      value: "${{ env.MODEL_NAME }}"
                    - name: DEPLOYED_AT
                      value: "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
                    - name: GIT_SHA
                      value: "${IMAGE_TAG}"
                  resources:
                    requests:
                      cpu: "100m"
                      memory: "256Mi"
                    limits:
                      cpu: "500m"
                      memory: "512Mi"
          EOF
      
      - name: Wait for deployment
        env:
          DEPLOY_NAMESPACE: ${{ steps.namespace.outputs.namespace }}
        run: |
          echo "â³ Waiting for InferenceService to be ready..."
          kubectl wait --for=condition=Ready \
            inferenceservice/${{ env.MODEL_NAME }} \
            -n ${DEPLOY_NAMESPACE} \
            --timeout=300s || true
          
          # ìƒíƒœ í™•ì¸
          kubectl get inferenceservice ${{ env.MODEL_NAME }} -n ${DEPLOY_NAMESPACE}
      
      - name: Get service URL
        env:
          DEPLOY_NAMESPACE: ${{ steps.namespace.outputs.namespace }}
        run: |
          URL=$(kubectl get inferenceservice ${{ env.MODEL_NAME }} -n ${DEPLOY_NAMESPACE} \
            -o jsonpath='{.status.url}' 2>/dev/null || echo "pending")
          echo "ğŸŒ Service URL: ${URL}"

  # ============================================================
  # Job 3: ë°°í¬ ê²€ì¦
  # ============================================================
  verify-deployment:
    name: Verify Deployment
    runs-on: ubuntu-latest
    needs: deploy-kserve
    
    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'
      
      - name: Configure kubeconfig
        run: |
          aws eks update-kubeconfig --name ${{ env.EKS_CLUSTER_NAME }} --region ${{ env.AWS_REGION }}
      
      - name: Set namespace
        id: namespace
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "namespace=${{ github.event.inputs.user_namespace }}" >> $GITHUB_OUTPUT
          else
            echo "namespace=${{ env.NAMESPACE }}" >> $GITHUB_OUTPUT
          fi
      
      - name: Health check
        env:
          DEPLOY_NAMESPACE: ${{ steps.namespace.outputs.namespace }}
        run: |
          echo "ğŸ” Checking deployment health..."
          
          # Pod ìƒíƒœ í™•ì¸
          kubectl get pods -n ${DEPLOY_NAMESPACE} -l serving.kserve.io/inferenceservice=${{ env.MODEL_NAME }}
          
          # InferenceService ìƒíƒœ
          STATUS=$(kubectl get inferenceservice ${{ env.MODEL_NAME }} -n ${DEPLOY_NAMESPACE} \
            -o jsonpath='{.status.conditions[?(@.type=="Ready")].status}')
          
          if [ "$STATUS" == "True" ]; then
            echo "âœ… Deployment is healthy!"
          else
            echo "âš ï¸ Deployment may not be fully ready"
            kubectl describe inferenceservice ${{ env.MODEL_NAME }} -n ${DEPLOY_NAMESPACE}
          fi
      
      - name: Smoke test (optional)
        env:
          DEPLOY_NAMESPACE: ${{ steps.namespace.outputs.namespace }}
        continue-on-error: true
        run: |
          echo "ğŸ§ª Running smoke test..."
          
          # ì„œë¹„ìŠ¤ URL ê°€ì ¸ì˜¤ê¸°
          SERVICE_URL=$(kubectl get inferenceservice ${{ env.MODEL_NAME }} -n ${DEPLOY_NAMESPACE} \
            -o jsonpath='{.status.url}')
          
          if [ -n "$SERVICE_URL" ]; then
            # ê°„ë‹¨í•œ í—¬ìŠ¤ ì²´í¬
            curl -s --max-time 10 "${SERVICE_URL}/v1/models/${{ env.MODEL_NAME }}" || echo "Health check endpoint not available"
          else
            echo "Service URL not available yet"
          fi

  # ============================================================
  # Job 4: ë°°í¬ ì™„ë£Œ ì•Œë¦¼
  # ============================================================
  notify:
    name: Notify Deployment
    runs-on: ubuntu-latest
    needs: [build-and-push, deploy-kserve, verify-deployment]
    if: always()
    
    steps:
      - name: Deployment Summary
        run: |
          echo "============================================================"
          echo "  Deployment Summary"
          echo "============================================================"
          echo ""
          echo "ğŸ“¦ Build: ${{ needs.build-and-push.result }}"
          echo "ğŸš€ Deploy: ${{ needs.deploy-kserve.result }}"
          echo "âœ… Verify: ${{ needs.verify-deployment.result }}"
          echo ""
          echo "ğŸ”— Details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          
          if [ "${{ needs.verify-deployment.result }}" == "success" ]; then
            echo ""
            echo "ğŸ‰ Deployment completed successfully!"
          else
            echo ""
            echo "âš ï¸ Deployment may have issues. Please check the logs."
          fi